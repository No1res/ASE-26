基于 RAACS 3.1（混合策略版）的代码逻辑，我们将代码角色及其识别规则总结如下。

这一版本的核心改进在于采用了 **“显式框架指纹（强信号）+ 隐式结构模式（语义信号）+ 路径暗示（弱信号）”** 的加权打分机制。

### 1. 角色定义与识别规则一览表

#### 🛠️ 基础设施与配置类

| **角色**                                | **定义**            | **显式指纹 (Strong Signals)**                                                                             | **结构模式 (Semantic Patterns)**                                                 | **路径/命名 (Hints)**                        |
| ------------------------------------- | ----------------- | ----------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- | ---------------------------------------- |
| **TEST**<br><br>  <br><br>(验证层)       | 单元测试、集成测试、Mock 数据 | • 导入 `pytest`, `unittest`<br><br>  <br><br>• 继承 `TestCase`<br><br>  <br><br>• 装饰器 `@fixture`, `@mock` | • **断言密度高** (assert 语句多)<br><br>  <br><br>• 函数体包含 `setup`/`teardown` 逻辑      | 文件名或路径含 `test`, `spec`, `tests`          |
| **CONFIG**<br><br>  <br><br>(配置层)     | 环境变量、常量定义、应用配置    | (无特定框架依赖)                                                                                             | • **纯声明式**：只有赋值，没有函数/类定义<br><br>  <br><br>• **常量占比高**：大写变量名 (UPPER_CASE) 比例高 | `config`, `settings`, `env`, `constants` |
| **SCRIPT**<br><br>  <br><br>(脚本层)     | CLI 工具、运维脚本、入口文件  | (无特定框架依赖)                                                                                             | • **入口点**：包含 `if __name__ == "__main__":`                                    | `script`, `cli`, `manage`, `bin`, `cmd`  |
| **NAMESPACE**<br><br>  <br><br>(命名空间) | 包管理文件，用于导出模块      | (无)                                                                                                   | • **纯净 Init**：文件名是 `__init__.py` 且不包含任何函数或类定义（仅 import）                      | `__init__.py`                            |

#### 🧱 数据与契约类

|**角色**|**定义**|**显式指纹 (Strong Signals)**|**结构模式 (Semantic Patterns)**|**路径/命名 (Hints)**|
|---|---|---|---|---|
|**SCHEMA**<br><br>  <br><br>(数据层)|数据模型、DTO、ORM 实体|• 导入 `pydantic`, `sqlalchemy`<br><br>  <br><br>• 继承 `BaseModel`, `Model`<br><br>  <br><br>• 装饰器 `@dataclass`|• **数据类特征**：字段定义数量远多于方法数量 (Fields >> Methods)<br><br>  <br><br>• 继承自 `Exception` (异常定义)|`schema`, `model`, `dto`, `entity`, `type`|
|**INTERFACE**<br><br>  <br><br>(抽象层)|接口定义、抽象基类、协议|• 继承 `ABC`, `Protocol`|• **抽象率高**：大部分方法为空 (`pass`) 或抛出 `NotImplementedError`|`interface`, `protocol`, `base`|

#### ⚙️ 业务与逻辑类

| **角色**                             | **定义**                | **显式指纹 (Strong Signals)**                                                                          | **结构模式 (Semantic Patterns)**                                                                                         | **路径/命名 (Hints)**                               |
| ---------------------------------- | --------------------- | -------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------- |
| **ADAPTER**<br><br>  <br><br>(适配层) | API 接口、路由处理、外部 I/O    | • Web 框架导入 (`flask`, `fastapi`, `django`)<br><br>  <br><br>• 路由装饰器 (`@route`, `@get`, `@api_view`) | • **IO 边界特征**：参数含 `request/ctx`，返回含 `response/json`<br><br>  <br><br>• **编排模式**：函数调用多 (Calls) 但控制流少 (Logic)，充当“胶水代码” | `api`, `view`, `controller`, `handler`, `route` |
| **UTIL**<br><br>  <br><br>(工具层)    | 无状态、通用的辅助函数           | (无)                                                                                                | • **低复杂度纯函数**：只有函数没有类；控制流简单；无 `self` 引用                                                                              | `util`, `helper`, `common`, `lib`               |
| **LOGIC**<br><br>  <br><br>(核心层)   | 核心业务逻辑 (Domain Logic) | (无，作为兜底角色)                                                                                         | • **高复杂度**：包含类定义，或函数内部控制流 (if/for) 较复杂<br><br>  <br><br>• **非以上角色**：既不是纯数据，也不是纯接口                                    | `service`, `core`, `logic`, `domain`            |

---

### 2. 核心识别策略总结

RAACS 3.1 的判断逻辑不再是线性的（if-else），而是**加权积分制**：

1. **优先级 1：显式指纹 (Weight: 4.0)**
    
    - 如果代码里明确 import 了 `Django` 并且用了 `@api_view`，它几乎 100% 是 **ADAPTER**。
        
    - 如果代码里继承了 `pydantic.BaseModel`，它几乎 100% 是 **SCHEMA**。
        
    - _优势：准确率极高，覆盖主流框架。_
        
2. **优先级 2：结构模式 (Weight: 2.5)**
    
    - 如果没有框架特征（比如自研框架），系统会分析代码的**长相（AST 结构）**。
        
    - 例子：一个类里面全是属性定义，没有方法 -> 推断为 **SCHEMA**。
        
    - 例子：一个函数参数叫 `request`，返回 `json` -> 推断为 **ADAPTER**。
        
    - _优势：具有泛化能力，能识别 Legacy 代码或未知框架。_
        
3. **优先级 3：路径暗示 (Weight: 1.5)**
    
    - 文件放在 `utils/` 目录下 -> 倾向于 **UTIL**。
        
    - 文件放在 `tests/` 目录下 -> 倾向于 **TEST**。
        
    - _优势：利用工程规范辅助判断。_
        
4. **兜底逻辑 (Fallback)**
    
    - 如果一个文件既没有框架特征，结构也很复杂（有类有逻辑），也不在特殊目录下，它会被归类为 **LOGIC**（核心业务逻辑）。